<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>star.Powerspectrum API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>star.Powerspectrum</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PowerSpectrum():
    &#34;&#34;&#34;
    Find the power spectrum by splitting the light curve into K segments. A power spectrum for 
    each segment is computed and the final power spectrum is the average over all these and the error
    is the standard error (sigma/K) over all these.

    **Parameters**:
    
    `lc`: class: &#39;Lightcurve&#39;-object   
        The light curve data to be Fourier-transformed.

    `m`: int   
        Number of time bins per segment. 

    `normalization`: {&#39;rms&#39; (Miyamoto), &#39;abs&#39;, &#39;Leahy&#39;, or &#39;none&#39;}, optional, default: &#39;rms&#39;.     
        What normalization to use, see Vaughan(2003, MNRAS 345).

    `noise`: {&#39;Poisson&#39;,&#39;Gaussian&#39;}, optional, default: &#39;Poisson&#39;.     
        For a light curve with &#39;Poisson&#39;/&#39;Gaussian&#39; errors. 
        
    `B_noise`: float, optional, default: 0     
        Background noise level to be used in the formula for the noise, see Eq. (A2) of Vaughan (2003, MNRAS 345).
        B_noise &lt; 1 means B=B_noise*R.
        B_noise = 2 means that B=np.sqrt(R).
        Else, B=B_noise.

    `percent_limit`: float, optional, default: 90     
        Lower limit for percent of time bins having to be filled, i.e. without gaps, for that segment to be used.

    `timer_on`: boolean, optional, default: True     
        If True, print out progress during computation.
        
    `return_noise_wo_sub`: boolean, optional, default: False     
        If True, noise is returned but not subtracted from powspec.
        If False, returned and subtracted.
        
    `save_all`: boolean, optional, default: False     
        If True, save rate_seg, err_seg, R_seg. These are needed for covariance-computation.
        
    `use_max_data`: boolean, optional, default: True
        If True: if a segment is disregarded due to a larger gap, the next segment will start directly after the gap. 
        If False: if a segment is disregarded, the placement of the next segment is not affected, which means that the data between the gap in the previous segment and the next segment is lost. 
    
    **Attributes**:
    
    `m`: int     
        Number of time bins per segment. 
    
    `channels`: string     
        Channels used during the observation.
    
    `Emin, Emax`: floats     
        Min and max energies of used energy band.
    
    `xf`: np.ndarray     
        The Fourier frequencies. 
    
    `df`: float     
        Frequency resolution.
    
    `fft_rate`: np.ndarray     
        Power spectra. Fast fourier transformation of, and average over all, rate_seg.
    
    `fft_rate_v`: list of np.ndarrays     
        Power spectra for each segment.
        
    `averagePnoise`: float     
        Average noise power for whole light curve.
    
    `Pnoise_v`: list of floats     
        Noise power for each segment.
    
    `Fvar`: float     
        Fractional variance amplitude (=rms) computed from the power spectra by integration.

    `middle_of_log_bins`: np.ndarray     
        The logarithmic midpoint of each log-bin, computed as: 10**(1/2*(np.log10(log_bins[i])+np.log10(log_bins[i+1])))
    
    `fPf`: np.ndarray     
        Power spectra multiplied with f and re-binned logarithmically.
    
    `fPferror`: np.ndarray     
        The standard deviation of all points within a log-bin for the fPf-vector.
    
    `Pf`: np.ndarray     
        Power spectra re-binned logarithmically.
    
    `Pferror`: np.ndarray     
        The standard deviation of all points within a log-bin for the Pf-vector.      
        
    ***In addition, if save_all == True***:
    
    `rate_seg_v`: np.ndarray     
        All segments&#39; rate-vectors.

    `err_seg_v`: np.ndarray     
        All segments&#39; rate-error-vectors.

    `R_seg_v`: np.ndarray     
        All segments&#39; mean count rates.
    &#34;&#34;&#34;
    
    def __init__(self, lc, m=2**13, normalization=&#39;rms&#39;, noise=&#39;Poisson&#39;, B_noise=0,                 percent_limit=90, timer_on=True, return_noise_wo_sub=False, save_all=False,                 use_max_data=True):
        self.m = m
        self.Emin, self.Emax = lc.Emin, lc.Emax
        self.xf, self.fft_rate, self.fft_rate_err, self.fft_rate_v, self.Pnoise_v = self.powspec(lc, normalization, noise, B_noise,percent_limit, timer_on, return_noise_wo_sub, save_all, use_max_data)
        self.df = self.xf[1]-self.xf[0]
        self.averagePnoise = np.mean(self.Pnoise_v)
        self.Fvar = self.Fvar_from_ps()
        self.middle_of_log_bins, self.fPf, self.fPferror, self.Pf, self.Pferror = self.rebin(init=True)
    
    def powspec(self,lc,normalization,noise,B_noise,percent_limit,timer_on,return_noise_wo_sub,save_all,use_max_data):
        &#34;&#34;&#34;
        Compute the power spectrum. For more info, see class doc.
        &#34;&#34;&#34;
        
        print(&#39;Computing the power spectra using {} bins per segment, normalization &#34;{}&#34;, and noise dist &#34;{}&#34;...&#39;.format(self.m,normalization,noise))
        
        # Useful parameters
        dt = lc.dt
        K = int(np.floor(lc.N/self.m)) #num_of_line_seg

        # Average over time segments 
        fft_rate_v = []
        P_noise_v = []
        rate_seg_v = []
        err_seg_v = []
        R_seg_v = []
        num_discarded_segments = 0
        start = timeit.default_timer()
        percent_wo_gaps_v = []
        
        i = 0
        num_of_iterations = K
        bins_back = 0 
        
        while i &lt; num_of_iterations:

            if timer_on:
                timer(i,num_of_iterations-1,start,clear=True)

            # Extract segment 
            t_seg, rate_seg, err_seg, N_gamma, R_seg, T_seg = lc.extract_seg(self.m,n=i,bins_back=bins_back,to_print=False,to_plot=False)

            if save_all:
                rate_seg_v.append(rate_seg)
                err_seg_v.append(err_seg)
                R_seg_v.append(R_seg)

            # Check gaps:
            ## Old version: if abs(dt*m - T_seg) &lt; 1e1: 
            percent_wo_gaps, hist = percent_of_filled_time_bins(t_seg,dt,to_return=True)
            
            if timer_on:
                print(&#39;percent of filled time bins (segment {}): {:.2f}&#39;.format(i,percent_wo_gaps))

            if percent_wo_gaps &gt; percent_limit: # if True, then there is no large gap in the segment
                
                # Perform FFT to find Power spectra for one seg
                xf, fft_rate_normalized, P_noise = self.fft_seg(dt,t_seg,rate_seg,err_seg,N_gamma,R_seg,normalization=normalization,noise=noise,B_noise=B_noise,return_noise_wo_sub=return_noise_wo_sub)
                fft_rate_v.append(fft_rate_normalized)
                P_noise_v.append(P_noise)
            
            else:
                percent_wo_gaps_v.append([i,percent_wo_gaps])
                num_discarded_segments += 1

                if use_max_data: # then start new segment directly after the end of a gap
                    
                    # Find last gap in segment
                    for j in range(1,len(hist)):
                        if hist[j-1] == 1 and hist[j] == 0:
                            bin_nr_after_which_no_gaps_exist = j
                    
                    # Take into account all previous gaps so that indexation becomes right 
                    # only relevant when we have more than 1 gap
                    zeros_until_last_gap = np.count_nonzero(hist[:bin_nr_after_which_no_gaps_exist]==0)
                    bin_nr_after_which_no_gaps_exist -= zeros_until_last_gap 
                    
                    # Compute how many steps back we should take in the next segment
                    bins_back += len(t_seg) - bin_nr_after_which_no_gaps_exist
                
                    # Might need to update the total number of segments we have
                    num_of_iterations = int(K + np.floor(bins_back/self.m))
            
            i += 1 

        print(&#39;{} of {} segments were disregarded due to lower percent limit set to {:.2f}%:&#39;.format(num_discarded_segments,num_of_iterations,percent_limit))
        if use_max_data:
            print(&#39;{} additional segments were used thanks to use_max_data == True&#39;.format(int(np.floor(bins_back/self.m))))
        print(&#39;\n&#39;.join(&#39;Seg nr = {}, percent of filled time bins = {:.2f}&#39;.format(k[1][0],k[1][1]) for k in enumerate(percent_wo_gaps_v)))
        print(&#39;Power spectra done! \n&#39;)

        if save_all:
            setattr(self, &#39;rate_seg_v&#39;, rate_seg_v)
            setattr(self, &#39;err_seg_v&#39;, err_seg_v)
            setattr(self, &#39;R_seg_v&#39;, R_seg_v)
        
        fft_rate_mean = np.mean(fft_rate_v,axis=0)
        fft_rate_err = np.std(fft_rate_v,axis=0)/np.sqrt(num_of_iterations-num_discarded_segments) # Standard Error

        return xf, fft_rate_mean, fft_rate_err, fft_rate_v, P_noise_v

    def fft_seg(self,dt,t_seg,rate_seg,err_seg,N_gamma,R_seg,normalization=&#39;rms&#39;,noise=&#39;Poisson&#39;,B_noise=0,t_d=0,return_noise_wo_sub=False,to_plot=True):
        &#34;&#34;&#34;
        Perform discrete FFT (fast-Fourier transform) on a light curve (lc) segment.

        **Parameters**: 
        
        `dt`: float     
            Time resolution.
        
        `t_seg`: np.ndarray     
            The segment&#39;s time-vector in seconds.

        `rate_seg`: np.ndarray     
            The segment&#39;s count rate(=flux)-vector in counts/seconds.

        `N_gamma`: int     
            Number of counted photons in the segment.

        `R_seg`: float     
            Mean count rate in the segment.

        `normalization`: {&#39;rms&#39; (Miyamoto), &#39;abs&#39;, &#39;Leahy&#39;, or &#39;none&#39;}, optional, default: &#39;rms&#39;.     
            What normalization to use, see Vaughan(2003, MNRAS 345).

        `noise`: {&#39;Poisson&#39;,&#39;Gaussian&#39;}, optional, default: &#39;Poisson&#39;.     
            For a light curve with &#34;noise&#34; errors.
            
        `B_noise`: float, optional, default: 0     
            Background noise level to be used in the formula for the noise, see Eq. (A2) of Vaughan (2003, MNRAS 345).
            B_noise &lt; 1 means B=B_noise*R.
            B_noise = 2 means that B=np.sqrt(R).
            else, B=B_noise.

        `t_d`: float (not implemented yet)     
            Dead-time of the instrument. 

        **Returns**:
        
        `xf`: np.array     
            The Fourier frequencies. 

        `fft_rate_noise_subtracted`: np.array     
            Fast fourier transformation of rate_seg. Noise subtraction has been made.
        &#34;&#34;&#34;
        
        # Perform FFT
        xf = np.array(fftfreq(self.m, dt)[1:self.m//2]) #only want positive freq
        fft_rate = fft(rate_seg)[1:self.m//2]

        # Normalize
        fft_rate = self.normalize_power(fft_rate,R_seg,dt,normalization)

        # Remove Noise
        P_noise = self.noise_power(dt,err_seg,R_seg,noise,normalization,B_noise)
        if not return_noise_wo_sub:
            fft_rate = np.array([x-P_noise for x in fft_rate])

        return xf, fft_rate, P_noise

    def noise_power(self,dt,err_seg,R,noise=&#39;Poisson&#39;,normalization=&#39;rms&#39;,B_noise=0,t_d=0):
        &#34;&#34;&#34;
        Calculate and return the Poisson noise power. See Appendix A of Vaughan (2003, MNRAS 345). Do not take dead time into account.

        **Parameters**:
        
        `R`: float     
            Mean count rate in the segment.

        `noise`: {&#39;Poisson&#39;,&#39;Gaussian&#39;}, optional, default: &#39;Poisson&#39;.     
            For a light curve with &#34;noise&#34; errors.

        `normalization`: {&#39;rms&#39; (Miyamoto), &#39;abs&#39;, &#39;Leahy&#39;, or &#39;none&#39;}, optional, default: &#39;rms&#39;.     
            What normalization to use, see Vaughan(2003, MNRAS 345).

        `B_noise`: float, optional, default: 0     
            Background noise level to be used in the formula for the noise, see Eq. (A2) of Vaughan (2003, MNRAS 345).
            B_noise &lt; 1 means B=B_noise*R.
            B_noise = 2 means that B=np.sqrt(R).
            else, B=B_noise.

        `t_d`: float (not implemented)     
            Dead time of instrument in seconds. 

        **Returns**:
        
        `P_noise`: float     
            Poisson noise power.
        &#34;&#34;&#34;

        dT_samp_over_dT_bin = 1
        
        if noise == &#39;Poisson&#39;: 
            if isinstance(B_noise, int) or isinstance(B_noise, float):
                if B_noise &lt; 1:
                    B=B_noise*R #B_noise=0.1 works for &#34;first&#34; CYG X-1 data
                elif B_noise == 2:
                    B=np.sqrt(R)
                else:
                    B=B_noise

            if normalization == &#39;rms&#39;:
                P_noise = 2*(R+B)/R**2*dT_samp_over_dT_bin
            elif normalization == &#39;Leahy&#39;: 
                P_noise = 2*(R+B)/R*dT_samp_over_dT_bin #should simply be =2 in most cases
            elif normalization == &#39;abs&#39;: 
                P_noise = 2*(R+B)/R**2*dT_samp_over_dT_bin
            else: #Poisson noise but w/o normalization
                P_noise = (R+B)*self.m/dt* dT_samp_over_dT_bin
        
        elif noise == &#39;Gaussian&#39;:
            if normalization == &#39;rms&#39;:
                P_noise = dT_samp_over_dT_bin*np.mean(err_seg**2)/(R**2*1/(2*dt))
            elif normalization == &#39;Leahy&#39; or normalization == &#39;abs&#39;:
                print(&#39;Sorry, cannot perform that normalization! Not implemented...!&#39;)
            else: #Gaussian noise but w/o normalization
                P_noise = np.mean(np.abs(err_seg)**2)*self.m
        
        else: #noise == &#39;None&#39;:
            P_noise = 0
            
        return P_noise

    def normalize_power(self,fft_rate,R,dt,normalization=&#39;rms&#39;):
        &#34;&#34;&#34;
        Normalize the power spectra. 

        **Parameters**:
        
        `fft_rate`: np.array     
            Fast fourier transformation of light curve. To be normalized.

        `R`: float     
            Mean count rate in the segment.

        `dt`: float     
            Time resoltuion in observation.

        `normalization`: {&#39;rms&#39; (Miyamoto), &#39;abs&#39;, &#39;Leahy&#39;, or &#39;none&#39;}, optional, default: &#39;rms&#39;.     
            What normalization to use, see Vaughan(2003, MNRAS 345).

        **Returns**:
        
        `normalized_power`: np.ndarray     
            The normalized power. 
        &#34;&#34;&#34;
        
        if normalization == &#39;rms&#39;:
            return np.array([2*dt/(R**2*self.m)*np.abs(x)**2 for x in fft_rate])
        elif normalization == &#39;Leahy&#39;:
            return np.array([2*dt/(R*self.m)*np.abs(x)**2 for x in fft_rate])    
        elif normalization == &#39;abs&#39;:      
            return np.array([2*dt/self.m*np.abs(x)**2 for x in fft_rate])    
        else: # no-normalization
            return np.array(fft_rate)
    
    def Fvar_from_ps(self):
        &#34;&#34;&#34;
        Calculate the fractional root mean square (rms) variability amplitude by integrating 
        the power spectra over the full frequency interval. **If** wants the Fvar in a **smaller freq-band**, 
        first use remove_freq() to set power to zero outside given freq band and then use Fvar_from_ps.

        **Returns**:
        
        `F_var`: float     
            The fractional root mean square (rms) variability amplitude.
        &#34;&#34;&#34;

        return Fvar_from_ps(self.xf,self.fft_rate)

    def rebin(self, num=50, init=False):
        &#34;&#34;&#34;
        Perform logarithmic rebinning.
        
        **Parameters**:
        
        `num`: int     
            The number of logarithmic frequency bins to create.
        
        `init`: boolean, optional, default: False     
            If False, creates the &#34;middle_of_log_bins, fPf, fPferror, Pf, Pferror&#34; for the first time with num=50 bins.
            If True, updates these attributes, using num bins.
            
        **Returns**:
        
        `middle_of_log_bins, fPf, fPferror, Pf, Pferror`: np.ndarrays     
            See class documentation. 
        &#34;&#34;&#34;
        
        middle_of_log_bins, fPf, fPferror = log_rebin(self.xf,self.fft_rate*self.xf,self.fft_rate_err*self.xf,num=num)
        middle_of_log_bins, Pf, Pferror = log_rebin(self.xf,self.fft_rate,self.fft_rate_err,num=num)
        
        if init:
            return middle_of_log_bins, fPf, fPferror, Pf, Pferror
        else:
            setattr(self, &#39;middle_of_log_bins&#39;, middle_of_log_bins)
            setattr(self, &#39;fPf&#39;, fPf)
            setattr(self, &#39;fPferror&#39;, fPferror)
            setattr(self, &#39;Pf&#39;, Pf)
            setattr(self, &#39;Pferror&#39;, Pferror)
    
    def plot(self,to_plot=&#39;fPf&#39;,w=10,with_noise=False,show=True,first=True,label=&#39;&#39;,color=None):
        &#34;&#34;&#34;
        Plot power spectrum times freq vs freq. (fPf) or power spectrum vs freq. (Pf).
        
        **Parameters**:
        
        `to_plot`: {&#39;fPf&#39;,&#39;Pf&#39;}     
            What to plot.
            
        `w`: int, optional, default: 10.
            Width of figure.
            
        `with_noise`: boolean, optional, default: False
            Also display the noise power.
        
        `show`: True   
            If True, show the plot. Needs to be False to be able to add more spectra to the same figure.
        
        `first`: True
            If True, create the figure. Needs to be False when adding more spectra to the same figure.
            
        `label`: str, optional, default: &#39;&#39;
            Label to plot. If default, the energy range will be displayed. 
            
        `color`: optional, default: None
            Color of graph.
            
        &#34;&#34;&#34;
        
        if first:
            ax = standard_plot(w=w)
        else:
            ax = plt.gca()
        
        if color == None:
            color = next(ax._get_lines.prop_cycler)[&#39;color&#39;]
        
        if label == &#39;&#39;:
            label = &#39;{}-{} keV&#39;.format(self.Emin,self.Emax)
        else:
            print(&#39;The energy band is: {}-{} keV&#39;.format(self.Emin,self.Emax))
        
        if to_plot == &#39;fPf&#39;:
            plt.step(self.middle_of_log_bins,self.fPf,where=&#39;mid&#39;,color=color,label=label)
            ax.errorbar(self.middle_of_log_bins,self.fPf,self.fPferror,fmt=&#39;,&#39;,color=color,elinewidth=1)
            plt.ylabel(&#39;Freq x Power&#39;) # P_f in [(RMS/Average)$^2$/Hz]
            if with_noise:
                plt.loglog(self.xf,self.xf*self.averagePnoise,label=&#39;Average Noise Power&#39;,color=&#39;k&#39;)
        elif to_plot == &#39;Pf&#39;:
            plt.step(self.middle_of_log_bins,self.Pf,where=&#39;mid&#39;,color=color,label=label)
            ax.errorbar(self.middle_of_log_bins,self.Pf,self.Pferror,fmt=&#39;,&#39;,color=color,elinewidth=1)
            plt.ylabel(&#39;Power&#39;) 
            if with_noise:
                ax.axhline(self.averagePnoise,label=&#39;Average Noise Power&#39;,color=&#39;k&#39;)        
        
        ax.set_xscale(&#39;log&#39;)
        ax.set_yscale(&#39;log&#39;)
        plt.xlabel(&#39;Frequency (Hz)&#39;)
        plt.legend()
        if show:
            plt.show()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="star.Powerspectrum.PowerSpectrum"><code class="flex name class">
<span>class <span class="ident">PowerSpectrum</span></span>
<span>(</span><span>lc, m=8192, normalization='rms', noise='Poisson', B_noise=0, percent_limit=90, timer_on=True, return_noise_wo_sub=False, save_all=False, use_max_data=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Find the power spectrum by splitting the light curve into K segments. A power spectrum for
each segment is computed and the final power spectrum is the average over all these and the error
is the standard error (sigma/K) over all these.</p>
<p><strong>Parameters</strong>:</p>
<p><code>lc</code>: class: 'Lightcurve'-object <br>
The light curve data to be Fourier-transformed.</p>
<p><code>m</code>: int <br>
Number of time bins per segment. </p>
<p><code>normalization</code>: {'rms' (Miyamoto), 'abs', 'Leahy', or 'none'}, optional, default: 'rms'.
<br>
What normalization to use, see Vaughan(2003, MNRAS 345).</p>
<p><code>noise</code>: {'Poisson','Gaussian'}, optional, default: 'Poisson'.
<br>
For a light curve with 'Poisson'/'Gaussian' errors. </p>
<p><code>B_noise</code>: float, optional, default: 0
<br>
Background noise level to be used in the formula for the noise, see Eq. (A2) of Vaughan (2003, MNRAS 345).
B_noise &lt; 1 means B=B_noise*R.
B_noise = 2 means that B=np.sqrt(R).
Else, B=B_noise.</p>
<p><code>percent_limit</code>: float, optional, default: 90
<br>
Lower limit for percent of time bins having to be filled, i.e. without gaps, for that segment to be used.</p>
<p><code>timer_on</code>: boolean, optional, default: True
<br>
If True, print out progress during computation.</p>
<p><code>return_noise_wo_sub</code>: boolean, optional, default: False
<br>
If True, noise is returned but not subtracted from powspec.
If False, returned and subtracted.</p>
<p><code>save_all</code>: boolean, optional, default: False
<br>
If True, save rate_seg, err_seg, R_seg. These are needed for covariance-computation.</p>
<p><code>use_max_data</code>: boolean, optional, default: True
If True: if a segment is disregarded due to a larger gap, the next segment will start directly after the gap.
If False: if a segment is disregarded, the placement of the next segment is not affected, which means that the data between the gap in the previous segment and the next segment is lost. </p>
<p><strong>Attributes</strong>:</p>
<p><code>m</code>: int
<br>
Number of time bins per segment. </p>
<p><code>channels</code>: string
<br>
Channels used during the observation.</p>
<p><code>Emin, Emax</code>: floats
<br>
Min and max energies of used energy band.</p>
<p><code>xf</code>: np.ndarray
<br>
The Fourier frequencies. </p>
<p><code>df</code>: float
<br>
Frequency resolution.</p>
<p><code>fft_rate</code>: np.ndarray
<br>
Power spectra. Fast fourier transformation of, and average over all, rate_seg.</p>
<p><code>fft_rate_v</code>: list of np.ndarrays
<br>
Power spectra for each segment.</p>
<p><code>averagePnoise</code>: float
<br>
Average noise power for whole light curve.</p>
<p><code>Pnoise_v</code>: list of floats
<br>
Noise power for each segment.</p>
<p><code>Fvar</code>: float
<br>
Fractional variance amplitude (=rms) computed from the power spectra by integration.</p>
<p><code>middle_of_log_bins</code>: np.ndarray
<br>
The logarithmic midpoint of each log-bin, computed as: 10*<em>(1/2</em>(np.log10(log_bins[i])+np.log10(log_bins[i+1])))</p>
<p><code>fPf</code>: np.ndarray
<br>
Power spectra multiplied with f and re-binned logarithmically.</p>
<p><code>fPferror</code>: np.ndarray
<br>
The standard deviation of all points within a log-bin for the fPf-vector.</p>
<p><code>Pf</code>: np.ndarray
<br>
Power spectra re-binned logarithmically.</p>
<p><code>Pferror</code>: np.ndarray
<br>
The standard deviation of all points within a log-bin for the Pf-vector.
</p>
<p><strong><em>In addition, if save_all == True</em></strong>:</p>
<p><code>rate_seg_v</code>: np.ndarray
<br>
All segments' rate-vectors.</p>
<p><code>err_seg_v</code>: np.ndarray
<br>
All segments' rate-error-vectors.</p>
<p><code>R_seg_v</code>: np.ndarray
<br>
All segments' mean count rates.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PowerSpectrum():
    &#34;&#34;&#34;
    Find the power spectrum by splitting the light curve into K segments. A power spectrum for 
    each segment is computed and the final power spectrum is the average over all these and the error
    is the standard error (sigma/K) over all these.

    **Parameters**:
    
    `lc`: class: &#39;Lightcurve&#39;-object   
        The light curve data to be Fourier-transformed.

    `m`: int   
        Number of time bins per segment. 

    `normalization`: {&#39;rms&#39; (Miyamoto), &#39;abs&#39;, &#39;Leahy&#39;, or &#39;none&#39;}, optional, default: &#39;rms&#39;.     
        What normalization to use, see Vaughan(2003, MNRAS 345).

    `noise`: {&#39;Poisson&#39;,&#39;Gaussian&#39;}, optional, default: &#39;Poisson&#39;.     
        For a light curve with &#39;Poisson&#39;/&#39;Gaussian&#39; errors. 
        
    `B_noise`: float, optional, default: 0     
        Background noise level to be used in the formula for the noise, see Eq. (A2) of Vaughan (2003, MNRAS 345).
        B_noise &lt; 1 means B=B_noise*R.
        B_noise = 2 means that B=np.sqrt(R).
        Else, B=B_noise.

    `percent_limit`: float, optional, default: 90     
        Lower limit for percent of time bins having to be filled, i.e. without gaps, for that segment to be used.

    `timer_on`: boolean, optional, default: True     
        If True, print out progress during computation.
        
    `return_noise_wo_sub`: boolean, optional, default: False     
        If True, noise is returned but not subtracted from powspec.
        If False, returned and subtracted.
        
    `save_all`: boolean, optional, default: False     
        If True, save rate_seg, err_seg, R_seg. These are needed for covariance-computation.
        
    `use_max_data`: boolean, optional, default: True
        If True: if a segment is disregarded due to a larger gap, the next segment will start directly after the gap. 
        If False: if a segment is disregarded, the placement of the next segment is not affected, which means that the data between the gap in the previous segment and the next segment is lost. 
    
    **Attributes**:
    
    `m`: int     
        Number of time bins per segment. 
    
    `channels`: string     
        Channels used during the observation.
    
    `Emin, Emax`: floats     
        Min and max energies of used energy band.
    
    `xf`: np.ndarray     
        The Fourier frequencies. 
    
    `df`: float     
        Frequency resolution.
    
    `fft_rate`: np.ndarray     
        Power spectra. Fast fourier transformation of, and average over all, rate_seg.
    
    `fft_rate_v`: list of np.ndarrays     
        Power spectra for each segment.
        
    `averagePnoise`: float     
        Average noise power for whole light curve.
    
    `Pnoise_v`: list of floats     
        Noise power for each segment.
    
    `Fvar`: float     
        Fractional variance amplitude (=rms) computed from the power spectra by integration.

    `middle_of_log_bins`: np.ndarray     
        The logarithmic midpoint of each log-bin, computed as: 10**(1/2*(np.log10(log_bins[i])+np.log10(log_bins[i+1])))
    
    `fPf`: np.ndarray     
        Power spectra multiplied with f and re-binned logarithmically.
    
    `fPferror`: np.ndarray     
        The standard deviation of all points within a log-bin for the fPf-vector.
    
    `Pf`: np.ndarray     
        Power spectra re-binned logarithmically.
    
    `Pferror`: np.ndarray     
        The standard deviation of all points within a log-bin for the Pf-vector.      
        
    ***In addition, if save_all == True***:
    
    `rate_seg_v`: np.ndarray     
        All segments&#39; rate-vectors.

    `err_seg_v`: np.ndarray     
        All segments&#39; rate-error-vectors.

    `R_seg_v`: np.ndarray     
        All segments&#39; mean count rates.
    &#34;&#34;&#34;
    
    def __init__(self, lc, m=2**13, normalization=&#39;rms&#39;, noise=&#39;Poisson&#39;, B_noise=0,                 percent_limit=90, timer_on=True, return_noise_wo_sub=False, save_all=False,                 use_max_data=True):
        self.m = m
        self.Emin, self.Emax = lc.Emin, lc.Emax
        self.xf, self.fft_rate, self.fft_rate_err, self.fft_rate_v, self.Pnoise_v = self.powspec(lc, normalization, noise, B_noise,percent_limit, timer_on, return_noise_wo_sub, save_all, use_max_data)
        self.df = self.xf[1]-self.xf[0]
        self.averagePnoise = np.mean(self.Pnoise_v)
        self.Fvar = self.Fvar_from_ps()
        self.middle_of_log_bins, self.fPf, self.fPferror, self.Pf, self.Pferror = self.rebin(init=True)
    
    def powspec(self,lc,normalization,noise,B_noise,percent_limit,timer_on,return_noise_wo_sub,save_all,use_max_data):
        &#34;&#34;&#34;
        Compute the power spectrum. For more info, see class doc.
        &#34;&#34;&#34;
        
        print(&#39;Computing the power spectra using {} bins per segment, normalization &#34;{}&#34;, and noise dist &#34;{}&#34;...&#39;.format(self.m,normalization,noise))
        
        # Useful parameters
        dt = lc.dt
        K = int(np.floor(lc.N/self.m)) #num_of_line_seg

        # Average over time segments 
        fft_rate_v = []
        P_noise_v = []
        rate_seg_v = []
        err_seg_v = []
        R_seg_v = []
        num_discarded_segments = 0
        start = timeit.default_timer()
        percent_wo_gaps_v = []
        
        i = 0
        num_of_iterations = K
        bins_back = 0 
        
        while i &lt; num_of_iterations:

            if timer_on:
                timer(i,num_of_iterations-1,start,clear=True)

            # Extract segment 
            t_seg, rate_seg, err_seg, N_gamma, R_seg, T_seg = lc.extract_seg(self.m,n=i,bins_back=bins_back,to_print=False,to_plot=False)

            if save_all:
                rate_seg_v.append(rate_seg)
                err_seg_v.append(err_seg)
                R_seg_v.append(R_seg)

            # Check gaps:
            ## Old version: if abs(dt*m - T_seg) &lt; 1e1: 
            percent_wo_gaps, hist = percent_of_filled_time_bins(t_seg,dt,to_return=True)
            
            if timer_on:
                print(&#39;percent of filled time bins (segment {}): {:.2f}&#39;.format(i,percent_wo_gaps))

            if percent_wo_gaps &gt; percent_limit: # if True, then there is no large gap in the segment
                
                # Perform FFT to find Power spectra for one seg
                xf, fft_rate_normalized, P_noise = self.fft_seg(dt,t_seg,rate_seg,err_seg,N_gamma,R_seg,normalization=normalization,noise=noise,B_noise=B_noise,return_noise_wo_sub=return_noise_wo_sub)
                fft_rate_v.append(fft_rate_normalized)
                P_noise_v.append(P_noise)
            
            else:
                percent_wo_gaps_v.append([i,percent_wo_gaps])
                num_discarded_segments += 1

                if use_max_data: # then start new segment directly after the end of a gap
                    
                    # Find last gap in segment
                    for j in range(1,len(hist)):
                        if hist[j-1] == 1 and hist[j] == 0:
                            bin_nr_after_which_no_gaps_exist = j
                    
                    # Take into account all previous gaps so that indexation becomes right 
                    # only relevant when we have more than 1 gap
                    zeros_until_last_gap = np.count_nonzero(hist[:bin_nr_after_which_no_gaps_exist]==0)
                    bin_nr_after_which_no_gaps_exist -= zeros_until_last_gap 
                    
                    # Compute how many steps back we should take in the next segment
                    bins_back += len(t_seg) - bin_nr_after_which_no_gaps_exist
                
                    # Might need to update the total number of segments we have
                    num_of_iterations = int(K + np.floor(bins_back/self.m))
            
            i += 1 

        print(&#39;{} of {} segments were disregarded due to lower percent limit set to {:.2f}%:&#39;.format(num_discarded_segments,num_of_iterations,percent_limit))
        if use_max_data:
            print(&#39;{} additional segments were used thanks to use_max_data == True&#39;.format(int(np.floor(bins_back/self.m))))
        print(&#39;\n&#39;.join(&#39;Seg nr = {}, percent of filled time bins = {:.2f}&#39;.format(k[1][0],k[1][1]) for k in enumerate(percent_wo_gaps_v)))
        print(&#39;Power spectra done! \n&#39;)

        if save_all:
            setattr(self, &#39;rate_seg_v&#39;, rate_seg_v)
            setattr(self, &#39;err_seg_v&#39;, err_seg_v)
            setattr(self, &#39;R_seg_v&#39;, R_seg_v)
        
        fft_rate_mean = np.mean(fft_rate_v,axis=0)
        fft_rate_err = np.std(fft_rate_v,axis=0)/np.sqrt(num_of_iterations-num_discarded_segments) # Standard Error

        return xf, fft_rate_mean, fft_rate_err, fft_rate_v, P_noise_v

    def fft_seg(self,dt,t_seg,rate_seg,err_seg,N_gamma,R_seg,normalization=&#39;rms&#39;,noise=&#39;Poisson&#39;,B_noise=0,t_d=0,return_noise_wo_sub=False,to_plot=True):
        &#34;&#34;&#34;
        Perform discrete FFT (fast-Fourier transform) on a light curve (lc) segment.

        **Parameters**: 
        
        `dt`: float     
            Time resolution.
        
        `t_seg`: np.ndarray     
            The segment&#39;s time-vector in seconds.

        `rate_seg`: np.ndarray     
            The segment&#39;s count rate(=flux)-vector in counts/seconds.

        `N_gamma`: int     
            Number of counted photons in the segment.

        `R_seg`: float     
            Mean count rate in the segment.

        `normalization`: {&#39;rms&#39; (Miyamoto), &#39;abs&#39;, &#39;Leahy&#39;, or &#39;none&#39;}, optional, default: &#39;rms&#39;.     
            What normalization to use, see Vaughan(2003, MNRAS 345).

        `noise`: {&#39;Poisson&#39;,&#39;Gaussian&#39;}, optional, default: &#39;Poisson&#39;.     
            For a light curve with &#34;noise&#34; errors.
            
        `B_noise`: float, optional, default: 0     
            Background noise level to be used in the formula for the noise, see Eq. (A2) of Vaughan (2003, MNRAS 345).
            B_noise &lt; 1 means B=B_noise*R.
            B_noise = 2 means that B=np.sqrt(R).
            else, B=B_noise.

        `t_d`: float (not implemented yet)     
            Dead-time of the instrument. 

        **Returns**:
        
        `xf`: np.array     
            The Fourier frequencies. 

        `fft_rate_noise_subtracted`: np.array     
            Fast fourier transformation of rate_seg. Noise subtraction has been made.
        &#34;&#34;&#34;
        
        # Perform FFT
        xf = np.array(fftfreq(self.m, dt)[1:self.m//2]) #only want positive freq
        fft_rate = fft(rate_seg)[1:self.m//2]

        # Normalize
        fft_rate = self.normalize_power(fft_rate,R_seg,dt,normalization)

        # Remove Noise
        P_noise = self.noise_power(dt,err_seg,R_seg,noise,normalization,B_noise)
        if not return_noise_wo_sub:
            fft_rate = np.array([x-P_noise for x in fft_rate])

        return xf, fft_rate, P_noise

    def noise_power(self,dt,err_seg,R,noise=&#39;Poisson&#39;,normalization=&#39;rms&#39;,B_noise=0,t_d=0):
        &#34;&#34;&#34;
        Calculate and return the Poisson noise power. See Appendix A of Vaughan (2003, MNRAS 345). Do not take dead time into account.

        **Parameters**:
        
        `R`: float     
            Mean count rate in the segment.

        `noise`: {&#39;Poisson&#39;,&#39;Gaussian&#39;}, optional, default: &#39;Poisson&#39;.     
            For a light curve with &#34;noise&#34; errors.

        `normalization`: {&#39;rms&#39; (Miyamoto), &#39;abs&#39;, &#39;Leahy&#39;, or &#39;none&#39;}, optional, default: &#39;rms&#39;.     
            What normalization to use, see Vaughan(2003, MNRAS 345).

        `B_noise`: float, optional, default: 0     
            Background noise level to be used in the formula for the noise, see Eq. (A2) of Vaughan (2003, MNRAS 345).
            B_noise &lt; 1 means B=B_noise*R.
            B_noise = 2 means that B=np.sqrt(R).
            else, B=B_noise.

        `t_d`: float (not implemented)     
            Dead time of instrument in seconds. 

        **Returns**:
        
        `P_noise`: float     
            Poisson noise power.
        &#34;&#34;&#34;

        dT_samp_over_dT_bin = 1
        
        if noise == &#39;Poisson&#39;: 
            if isinstance(B_noise, int) or isinstance(B_noise, float):
                if B_noise &lt; 1:
                    B=B_noise*R #B_noise=0.1 works for &#34;first&#34; CYG X-1 data
                elif B_noise == 2:
                    B=np.sqrt(R)
                else:
                    B=B_noise

            if normalization == &#39;rms&#39;:
                P_noise = 2*(R+B)/R**2*dT_samp_over_dT_bin
            elif normalization == &#39;Leahy&#39;: 
                P_noise = 2*(R+B)/R*dT_samp_over_dT_bin #should simply be =2 in most cases
            elif normalization == &#39;abs&#39;: 
                P_noise = 2*(R+B)/R**2*dT_samp_over_dT_bin
            else: #Poisson noise but w/o normalization
                P_noise = (R+B)*self.m/dt* dT_samp_over_dT_bin
        
        elif noise == &#39;Gaussian&#39;:
            if normalization == &#39;rms&#39;:
                P_noise = dT_samp_over_dT_bin*np.mean(err_seg**2)/(R**2*1/(2*dt))
            elif normalization == &#39;Leahy&#39; or normalization == &#39;abs&#39;:
                print(&#39;Sorry, cannot perform that normalization! Not implemented...!&#39;)
            else: #Gaussian noise but w/o normalization
                P_noise = np.mean(np.abs(err_seg)**2)*self.m
        
        else: #noise == &#39;None&#39;:
            P_noise = 0
            
        return P_noise

    def normalize_power(self,fft_rate,R,dt,normalization=&#39;rms&#39;):
        &#34;&#34;&#34;
        Normalize the power spectra. 

        **Parameters**:
        
        `fft_rate`: np.array     
            Fast fourier transformation of light curve. To be normalized.

        `R`: float     
            Mean count rate in the segment.

        `dt`: float     
            Time resoltuion in observation.

        `normalization`: {&#39;rms&#39; (Miyamoto), &#39;abs&#39;, &#39;Leahy&#39;, or &#39;none&#39;}, optional, default: &#39;rms&#39;.     
            What normalization to use, see Vaughan(2003, MNRAS 345).

        **Returns**:
        
        `normalized_power`: np.ndarray     
            The normalized power. 
        &#34;&#34;&#34;
        
        if normalization == &#39;rms&#39;:
            return np.array([2*dt/(R**2*self.m)*np.abs(x)**2 for x in fft_rate])
        elif normalization == &#39;Leahy&#39;:
            return np.array([2*dt/(R*self.m)*np.abs(x)**2 for x in fft_rate])    
        elif normalization == &#39;abs&#39;:      
            return np.array([2*dt/self.m*np.abs(x)**2 for x in fft_rate])    
        else: # no-normalization
            return np.array(fft_rate)
    
    def Fvar_from_ps(self):
        &#34;&#34;&#34;
        Calculate the fractional root mean square (rms) variability amplitude by integrating 
        the power spectra over the full frequency interval. **If** wants the Fvar in a **smaller freq-band**, 
        first use remove_freq() to set power to zero outside given freq band and then use Fvar_from_ps.

        **Returns**:
        
        `F_var`: float     
            The fractional root mean square (rms) variability amplitude.
        &#34;&#34;&#34;

        return Fvar_from_ps(self.xf,self.fft_rate)

    def rebin(self, num=50, init=False):
        &#34;&#34;&#34;
        Perform logarithmic rebinning.
        
        **Parameters**:
        
        `num`: int     
            The number of logarithmic frequency bins to create.
        
        `init`: boolean, optional, default: False     
            If False, creates the &#34;middle_of_log_bins, fPf, fPferror, Pf, Pferror&#34; for the first time with num=50 bins.
            If True, updates these attributes, using num bins.
            
        **Returns**:
        
        `middle_of_log_bins, fPf, fPferror, Pf, Pferror`: np.ndarrays     
            See class documentation. 
        &#34;&#34;&#34;
        
        middle_of_log_bins, fPf, fPferror = log_rebin(self.xf,self.fft_rate*self.xf,self.fft_rate_err*self.xf,num=num)
        middle_of_log_bins, Pf, Pferror = log_rebin(self.xf,self.fft_rate,self.fft_rate_err,num=num)
        
        if init:
            return middle_of_log_bins, fPf, fPferror, Pf, Pferror
        else:
            setattr(self, &#39;middle_of_log_bins&#39;, middle_of_log_bins)
            setattr(self, &#39;fPf&#39;, fPf)
            setattr(self, &#39;fPferror&#39;, fPferror)
            setattr(self, &#39;Pf&#39;, Pf)
            setattr(self, &#39;Pferror&#39;, Pferror)
    
    def plot(self,to_plot=&#39;fPf&#39;,w=10,with_noise=False,show=True,first=True,label=&#39;&#39;,color=None):
        &#34;&#34;&#34;
        Plot power spectrum times freq vs freq. (fPf) or power spectrum vs freq. (Pf).
        
        **Parameters**:
        
        `to_plot`: {&#39;fPf&#39;,&#39;Pf&#39;}     
            What to plot.
            
        `w`: int, optional, default: 10.
            Width of figure.
            
        `with_noise`: boolean, optional, default: False
            Also display the noise power.
        
        `show`: True   
            If True, show the plot. Needs to be False to be able to add more spectra to the same figure.
        
        `first`: True
            If True, create the figure. Needs to be False when adding more spectra to the same figure.
            
        `label`: str, optional, default: &#39;&#39;
            Label to plot. If default, the energy range will be displayed. 
            
        `color`: optional, default: None
            Color of graph.
            
        &#34;&#34;&#34;
        
        if first:
            ax = standard_plot(w=w)
        else:
            ax = plt.gca()
        
        if color == None:
            color = next(ax._get_lines.prop_cycler)[&#39;color&#39;]
        
        if label == &#39;&#39;:
            label = &#39;{}-{} keV&#39;.format(self.Emin,self.Emax)
        else:
            print(&#39;The energy band is: {}-{} keV&#39;.format(self.Emin,self.Emax))
        
        if to_plot == &#39;fPf&#39;:
            plt.step(self.middle_of_log_bins,self.fPf,where=&#39;mid&#39;,color=color,label=label)
            ax.errorbar(self.middle_of_log_bins,self.fPf,self.fPferror,fmt=&#39;,&#39;,color=color,elinewidth=1)
            plt.ylabel(&#39;Freq x Power&#39;) # P_f in [(RMS/Average)$^2$/Hz]
            if with_noise:
                plt.loglog(self.xf,self.xf*self.averagePnoise,label=&#39;Average Noise Power&#39;,color=&#39;k&#39;)
        elif to_plot == &#39;Pf&#39;:
            plt.step(self.middle_of_log_bins,self.Pf,where=&#39;mid&#39;,color=color,label=label)
            ax.errorbar(self.middle_of_log_bins,self.Pf,self.Pferror,fmt=&#39;,&#39;,color=color,elinewidth=1)
            plt.ylabel(&#39;Power&#39;) 
            if with_noise:
                ax.axhline(self.averagePnoise,label=&#39;Average Noise Power&#39;,color=&#39;k&#39;)        
        
        ax.set_xscale(&#39;log&#39;)
        ax.set_yscale(&#39;log&#39;)
        plt.xlabel(&#39;Frequency (Hz)&#39;)
        plt.legend()
        if show:
            plt.show()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="star.Powerspectrum.PowerSpectrum.Fvar_from_ps"><code class="name flex">
<span>def <span class="ident">Fvar_from_ps</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the fractional root mean square (rms) variability amplitude by integrating
the power spectra over the full frequency interval. <strong>If</strong> wants the Fvar in a <strong>smaller freq-band</strong>,
first use remove_freq() to set power to zero outside given freq band and then use Fvar_from_ps.</p>
<p><strong>Returns</strong>:</p>
<p><code>F_var</code>: float
<br>
The fractional root mean square (rms) variability amplitude.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Fvar_from_ps(self):
    &#34;&#34;&#34;
    Calculate the fractional root mean square (rms) variability amplitude by integrating 
    the power spectra over the full frequency interval. **If** wants the Fvar in a **smaller freq-band**, 
    first use remove_freq() to set power to zero outside given freq band and then use Fvar_from_ps.

    **Returns**:
    
    `F_var`: float     
        The fractional root mean square (rms) variability amplitude.
    &#34;&#34;&#34;

    return Fvar_from_ps(self.xf,self.fft_rate)</code></pre>
</details>
</dd>
<dt id="star.Powerspectrum.PowerSpectrum.fft_seg"><code class="name flex">
<span>def <span class="ident">fft_seg</span></span>(<span>self, dt, t_seg, rate_seg, err_seg, N_gamma, R_seg, normalization='rms', noise='Poisson', B_noise=0, t_d=0, return_noise_wo_sub=False, to_plot=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Perform discrete FFT (fast-Fourier transform) on a light curve (lc) segment.</p>
<p><strong>Parameters</strong>: </p>
<p><code>dt</code>: float
<br>
Time resolution.</p>
<p><code>t_seg</code>: np.ndarray
<br>
The segment's time-vector in seconds.</p>
<p><code>rate_seg</code>: np.ndarray
<br>
The segment's count rate(=flux)-vector in counts/seconds.</p>
<p><code>N_gamma</code>: int
<br>
Number of counted photons in the segment.</p>
<p><code>R_seg</code>: float
<br>
Mean count rate in the segment.</p>
<p><code>normalization</code>: {'rms' (Miyamoto), 'abs', 'Leahy', or 'none'}, optional, default: 'rms'.
<br>
What normalization to use, see Vaughan(2003, MNRAS 345).</p>
<p><code>noise</code>: {'Poisson','Gaussian'}, optional, default: 'Poisson'.
<br>
For a light curve with "noise" errors.</p>
<p><code>B_noise</code>: float, optional, default: 0
<br>
Background noise level to be used in the formula for the noise, see Eq. (A2) of Vaughan (2003, MNRAS 345).
B_noise &lt; 1 means B=B_noise*R.
B_noise = 2 means that B=np.sqrt(R).
else, B=B_noise.</p>
<p><code>t_d</code>: float (not implemented yet)
<br>
Dead-time of the instrument. </p>
<p><strong>Returns</strong>:</p>
<p><code>xf</code>: np.array
<br>
The Fourier frequencies. </p>
<p><code>fft_rate_noise_subtracted</code>: np.array
<br>
Fast fourier transformation of rate_seg. Noise subtraction has been made.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fft_seg(self,dt,t_seg,rate_seg,err_seg,N_gamma,R_seg,normalization=&#39;rms&#39;,noise=&#39;Poisson&#39;,B_noise=0,t_d=0,return_noise_wo_sub=False,to_plot=True):
    &#34;&#34;&#34;
    Perform discrete FFT (fast-Fourier transform) on a light curve (lc) segment.

    **Parameters**: 
    
    `dt`: float     
        Time resolution.
    
    `t_seg`: np.ndarray     
        The segment&#39;s time-vector in seconds.

    `rate_seg`: np.ndarray     
        The segment&#39;s count rate(=flux)-vector in counts/seconds.

    `N_gamma`: int     
        Number of counted photons in the segment.

    `R_seg`: float     
        Mean count rate in the segment.

    `normalization`: {&#39;rms&#39; (Miyamoto), &#39;abs&#39;, &#39;Leahy&#39;, or &#39;none&#39;}, optional, default: &#39;rms&#39;.     
        What normalization to use, see Vaughan(2003, MNRAS 345).

    `noise`: {&#39;Poisson&#39;,&#39;Gaussian&#39;}, optional, default: &#39;Poisson&#39;.     
        For a light curve with &#34;noise&#34; errors.
        
    `B_noise`: float, optional, default: 0     
        Background noise level to be used in the formula for the noise, see Eq. (A2) of Vaughan (2003, MNRAS 345).
        B_noise &lt; 1 means B=B_noise*R.
        B_noise = 2 means that B=np.sqrt(R).
        else, B=B_noise.

    `t_d`: float (not implemented yet)     
        Dead-time of the instrument. 

    **Returns**:
    
    `xf`: np.array     
        The Fourier frequencies. 

    `fft_rate_noise_subtracted`: np.array     
        Fast fourier transformation of rate_seg. Noise subtraction has been made.
    &#34;&#34;&#34;
    
    # Perform FFT
    xf = np.array(fftfreq(self.m, dt)[1:self.m//2]) #only want positive freq
    fft_rate = fft(rate_seg)[1:self.m//2]

    # Normalize
    fft_rate = self.normalize_power(fft_rate,R_seg,dt,normalization)

    # Remove Noise
    P_noise = self.noise_power(dt,err_seg,R_seg,noise,normalization,B_noise)
    if not return_noise_wo_sub:
        fft_rate = np.array([x-P_noise for x in fft_rate])

    return xf, fft_rate, P_noise</code></pre>
</details>
</dd>
<dt id="star.Powerspectrum.PowerSpectrum.noise_power"><code class="name flex">
<span>def <span class="ident">noise_power</span></span>(<span>self, dt, err_seg, R, noise='Poisson', normalization='rms', B_noise=0, t_d=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate and return the Poisson noise power. See Appendix A of Vaughan (2003, MNRAS 345). Do not take dead time into account.</p>
<p><strong>Parameters</strong>:</p>
<p><code>R</code>: float
<br>
Mean count rate in the segment.</p>
<p><code>noise</code>: {'Poisson','Gaussian'}, optional, default: 'Poisson'.
<br>
For a light curve with "noise" errors.</p>
<p><code>normalization</code>: {'rms' (Miyamoto), 'abs', 'Leahy', or 'none'}, optional, default: 'rms'.
<br>
What normalization to use, see Vaughan(2003, MNRAS 345).</p>
<p><code>B_noise</code>: float, optional, default: 0
<br>
Background noise level to be used in the formula for the noise, see Eq. (A2) of Vaughan (2003, MNRAS 345).
B_noise &lt; 1 means B=B_noise*R.
B_noise = 2 means that B=np.sqrt(R).
else, B=B_noise.</p>
<p><code>t_d</code>: float (not implemented)
<br>
Dead time of instrument in seconds. </p>
<p><strong>Returns</strong>:</p>
<p><code>P_noise</code>: float
<br>
Poisson noise power.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def noise_power(self,dt,err_seg,R,noise=&#39;Poisson&#39;,normalization=&#39;rms&#39;,B_noise=0,t_d=0):
    &#34;&#34;&#34;
    Calculate and return the Poisson noise power. See Appendix A of Vaughan (2003, MNRAS 345). Do not take dead time into account.

    **Parameters**:
    
    `R`: float     
        Mean count rate in the segment.

    `noise`: {&#39;Poisson&#39;,&#39;Gaussian&#39;}, optional, default: &#39;Poisson&#39;.     
        For a light curve with &#34;noise&#34; errors.

    `normalization`: {&#39;rms&#39; (Miyamoto), &#39;abs&#39;, &#39;Leahy&#39;, or &#39;none&#39;}, optional, default: &#39;rms&#39;.     
        What normalization to use, see Vaughan(2003, MNRAS 345).

    `B_noise`: float, optional, default: 0     
        Background noise level to be used in the formula for the noise, see Eq. (A2) of Vaughan (2003, MNRAS 345).
        B_noise &lt; 1 means B=B_noise*R.
        B_noise = 2 means that B=np.sqrt(R).
        else, B=B_noise.

    `t_d`: float (not implemented)     
        Dead time of instrument in seconds. 

    **Returns**:
    
    `P_noise`: float     
        Poisson noise power.
    &#34;&#34;&#34;

    dT_samp_over_dT_bin = 1
    
    if noise == &#39;Poisson&#39;: 
        if isinstance(B_noise, int) or isinstance(B_noise, float):
            if B_noise &lt; 1:
                B=B_noise*R #B_noise=0.1 works for &#34;first&#34; CYG X-1 data
            elif B_noise == 2:
                B=np.sqrt(R)
            else:
                B=B_noise

        if normalization == &#39;rms&#39;:
            P_noise = 2*(R+B)/R**2*dT_samp_over_dT_bin
        elif normalization == &#39;Leahy&#39;: 
            P_noise = 2*(R+B)/R*dT_samp_over_dT_bin #should simply be =2 in most cases
        elif normalization == &#39;abs&#39;: 
            P_noise = 2*(R+B)/R**2*dT_samp_over_dT_bin
        else: #Poisson noise but w/o normalization
            P_noise = (R+B)*self.m/dt* dT_samp_over_dT_bin
    
    elif noise == &#39;Gaussian&#39;:
        if normalization == &#39;rms&#39;:
            P_noise = dT_samp_over_dT_bin*np.mean(err_seg**2)/(R**2*1/(2*dt))
        elif normalization == &#39;Leahy&#39; or normalization == &#39;abs&#39;:
            print(&#39;Sorry, cannot perform that normalization! Not implemented...!&#39;)
        else: #Gaussian noise but w/o normalization
            P_noise = np.mean(np.abs(err_seg)**2)*self.m
    
    else: #noise == &#39;None&#39;:
        P_noise = 0
        
    return P_noise</code></pre>
</details>
</dd>
<dt id="star.Powerspectrum.PowerSpectrum.normalize_power"><code class="name flex">
<span>def <span class="ident">normalize_power</span></span>(<span>self, fft_rate, R, dt, normalization='rms')</span>
</code></dt>
<dd>
<div class="desc"><p>Normalize the power spectra. </p>
<p><strong>Parameters</strong>:</p>
<p><code>fft_rate</code>: np.array
<br>
Fast fourier transformation of light curve. To be normalized.</p>
<p><code>R</code>: float
<br>
Mean count rate in the segment.</p>
<p><code>dt</code>: float
<br>
Time resoltuion in observation.</p>
<p><code>normalization</code>: {'rms' (Miyamoto), 'abs', 'Leahy', or 'none'}, optional, default: 'rms'.
<br>
What normalization to use, see Vaughan(2003, MNRAS 345).</p>
<p><strong>Returns</strong>:</p>
<p><code>normalized_power</code>: np.ndarray
<br>
The normalized power.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def normalize_power(self,fft_rate,R,dt,normalization=&#39;rms&#39;):
    &#34;&#34;&#34;
    Normalize the power spectra. 

    **Parameters**:
    
    `fft_rate`: np.array     
        Fast fourier transformation of light curve. To be normalized.

    `R`: float     
        Mean count rate in the segment.

    `dt`: float     
        Time resoltuion in observation.

    `normalization`: {&#39;rms&#39; (Miyamoto), &#39;abs&#39;, &#39;Leahy&#39;, or &#39;none&#39;}, optional, default: &#39;rms&#39;.     
        What normalization to use, see Vaughan(2003, MNRAS 345).

    **Returns**:
    
    `normalized_power`: np.ndarray     
        The normalized power. 
    &#34;&#34;&#34;
    
    if normalization == &#39;rms&#39;:
        return np.array([2*dt/(R**2*self.m)*np.abs(x)**2 for x in fft_rate])
    elif normalization == &#39;Leahy&#39;:
        return np.array([2*dt/(R*self.m)*np.abs(x)**2 for x in fft_rate])    
    elif normalization == &#39;abs&#39;:      
        return np.array([2*dt/self.m*np.abs(x)**2 for x in fft_rate])    
    else: # no-normalization
        return np.array(fft_rate)</code></pre>
</details>
</dd>
<dt id="star.Powerspectrum.PowerSpectrum.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>self, to_plot='fPf', w=10, with_noise=False, show=True, first=True, label='', color=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot power spectrum times freq vs freq. (fPf) or power spectrum vs freq. (Pf).</p>
<p><strong>Parameters</strong>:</p>
<p><code>to_plot</code>: {'fPf','Pf'}
<br>
What to plot.</p>
<p><code>w</code>: int, optional, default: 10.
Width of figure.</p>
<p><code>with_noise</code>: boolean, optional, default: False
Also display the noise power.</p>
<p><code>show</code>: True <br>
If True, show the plot. Needs to be False to be able to add more spectra to the same figure.</p>
<p><code>first</code>: True
If True, create the figure. Needs to be False when adding more spectra to the same figure.</p>
<p><code>label</code>: str, optional, default: ''
Label to plot. If default, the energy range will be displayed. </p>
<p><code>color</code>: optional, default: None
Color of graph.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(self,to_plot=&#39;fPf&#39;,w=10,with_noise=False,show=True,first=True,label=&#39;&#39;,color=None):
    &#34;&#34;&#34;
    Plot power spectrum times freq vs freq. (fPf) or power spectrum vs freq. (Pf).
    
    **Parameters**:
    
    `to_plot`: {&#39;fPf&#39;,&#39;Pf&#39;}     
        What to plot.
        
    `w`: int, optional, default: 10.
        Width of figure.
        
    `with_noise`: boolean, optional, default: False
        Also display the noise power.
    
    `show`: True   
        If True, show the plot. Needs to be False to be able to add more spectra to the same figure.
    
    `first`: True
        If True, create the figure. Needs to be False when adding more spectra to the same figure.
        
    `label`: str, optional, default: &#39;&#39;
        Label to plot. If default, the energy range will be displayed. 
        
    `color`: optional, default: None
        Color of graph.
        
    &#34;&#34;&#34;
    
    if first:
        ax = standard_plot(w=w)
    else:
        ax = plt.gca()
    
    if color == None:
        color = next(ax._get_lines.prop_cycler)[&#39;color&#39;]
    
    if label == &#39;&#39;:
        label = &#39;{}-{} keV&#39;.format(self.Emin,self.Emax)
    else:
        print(&#39;The energy band is: {}-{} keV&#39;.format(self.Emin,self.Emax))
    
    if to_plot == &#39;fPf&#39;:
        plt.step(self.middle_of_log_bins,self.fPf,where=&#39;mid&#39;,color=color,label=label)
        ax.errorbar(self.middle_of_log_bins,self.fPf,self.fPferror,fmt=&#39;,&#39;,color=color,elinewidth=1)
        plt.ylabel(&#39;Freq x Power&#39;) # P_f in [(RMS/Average)$^2$/Hz]
        if with_noise:
            plt.loglog(self.xf,self.xf*self.averagePnoise,label=&#39;Average Noise Power&#39;,color=&#39;k&#39;)
    elif to_plot == &#39;Pf&#39;:
        plt.step(self.middle_of_log_bins,self.Pf,where=&#39;mid&#39;,color=color,label=label)
        ax.errorbar(self.middle_of_log_bins,self.Pf,self.Pferror,fmt=&#39;,&#39;,color=color,elinewidth=1)
        plt.ylabel(&#39;Power&#39;) 
        if with_noise:
            ax.axhline(self.averagePnoise,label=&#39;Average Noise Power&#39;,color=&#39;k&#39;)        
    
    ax.set_xscale(&#39;log&#39;)
    ax.set_yscale(&#39;log&#39;)
    plt.xlabel(&#39;Frequency (Hz)&#39;)
    plt.legend()
    if show:
        plt.show()</code></pre>
</details>
</dd>
<dt id="star.Powerspectrum.PowerSpectrum.powspec"><code class="name flex">
<span>def <span class="ident">powspec</span></span>(<span>self, lc, normalization, noise, B_noise, percent_limit, timer_on, return_noise_wo_sub, save_all, use_max_data)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the power spectrum. For more info, see class doc.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def powspec(self,lc,normalization,noise,B_noise,percent_limit,timer_on,return_noise_wo_sub,save_all,use_max_data):
    &#34;&#34;&#34;
    Compute the power spectrum. For more info, see class doc.
    &#34;&#34;&#34;
    
    print(&#39;Computing the power spectra using {} bins per segment, normalization &#34;{}&#34;, and noise dist &#34;{}&#34;...&#39;.format(self.m,normalization,noise))
    
    # Useful parameters
    dt = lc.dt
    K = int(np.floor(lc.N/self.m)) #num_of_line_seg

    # Average over time segments 
    fft_rate_v = []
    P_noise_v = []
    rate_seg_v = []
    err_seg_v = []
    R_seg_v = []
    num_discarded_segments = 0
    start = timeit.default_timer()
    percent_wo_gaps_v = []
    
    i = 0
    num_of_iterations = K
    bins_back = 0 
    
    while i &lt; num_of_iterations:

        if timer_on:
            timer(i,num_of_iterations-1,start,clear=True)

        # Extract segment 
        t_seg, rate_seg, err_seg, N_gamma, R_seg, T_seg = lc.extract_seg(self.m,n=i,bins_back=bins_back,to_print=False,to_plot=False)

        if save_all:
            rate_seg_v.append(rate_seg)
            err_seg_v.append(err_seg)
            R_seg_v.append(R_seg)

        # Check gaps:
        ## Old version: if abs(dt*m - T_seg) &lt; 1e1: 
        percent_wo_gaps, hist = percent_of_filled_time_bins(t_seg,dt,to_return=True)
        
        if timer_on:
            print(&#39;percent of filled time bins (segment {}): {:.2f}&#39;.format(i,percent_wo_gaps))

        if percent_wo_gaps &gt; percent_limit: # if True, then there is no large gap in the segment
            
            # Perform FFT to find Power spectra for one seg
            xf, fft_rate_normalized, P_noise = self.fft_seg(dt,t_seg,rate_seg,err_seg,N_gamma,R_seg,normalization=normalization,noise=noise,B_noise=B_noise,return_noise_wo_sub=return_noise_wo_sub)
            fft_rate_v.append(fft_rate_normalized)
            P_noise_v.append(P_noise)
        
        else:
            percent_wo_gaps_v.append([i,percent_wo_gaps])
            num_discarded_segments += 1

            if use_max_data: # then start new segment directly after the end of a gap
                
                # Find last gap in segment
                for j in range(1,len(hist)):
                    if hist[j-1] == 1 and hist[j] == 0:
                        bin_nr_after_which_no_gaps_exist = j
                
                # Take into account all previous gaps so that indexation becomes right 
                # only relevant when we have more than 1 gap
                zeros_until_last_gap = np.count_nonzero(hist[:bin_nr_after_which_no_gaps_exist]==0)
                bin_nr_after_which_no_gaps_exist -= zeros_until_last_gap 
                
                # Compute how many steps back we should take in the next segment
                bins_back += len(t_seg) - bin_nr_after_which_no_gaps_exist
            
                # Might need to update the total number of segments we have
                num_of_iterations = int(K + np.floor(bins_back/self.m))
        
        i += 1 

    print(&#39;{} of {} segments were disregarded due to lower percent limit set to {:.2f}%:&#39;.format(num_discarded_segments,num_of_iterations,percent_limit))
    if use_max_data:
        print(&#39;{} additional segments were used thanks to use_max_data == True&#39;.format(int(np.floor(bins_back/self.m))))
    print(&#39;\n&#39;.join(&#39;Seg nr = {}, percent of filled time bins = {:.2f}&#39;.format(k[1][0],k[1][1]) for k in enumerate(percent_wo_gaps_v)))
    print(&#39;Power spectra done! \n&#39;)

    if save_all:
        setattr(self, &#39;rate_seg_v&#39;, rate_seg_v)
        setattr(self, &#39;err_seg_v&#39;, err_seg_v)
        setattr(self, &#39;R_seg_v&#39;, R_seg_v)
    
    fft_rate_mean = np.mean(fft_rate_v,axis=0)
    fft_rate_err = np.std(fft_rate_v,axis=0)/np.sqrt(num_of_iterations-num_discarded_segments) # Standard Error

    return xf, fft_rate_mean, fft_rate_err, fft_rate_v, P_noise_v</code></pre>
</details>
</dd>
<dt id="star.Powerspectrum.PowerSpectrum.rebin"><code class="name flex">
<span>def <span class="ident">rebin</span></span>(<span>self, num=50, init=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Perform logarithmic rebinning.</p>
<p><strong>Parameters</strong>:</p>
<p><code>num</code>: int
<br>
The number of logarithmic frequency bins to create.</p>
<p><code>init</code>: boolean, optional, default: False
<br>
If False, creates the "middle_of_log_bins, fPf, fPferror, Pf, Pferror" for the first time with num=50 bins.
If True, updates these attributes, using num bins.</p>
<p><strong>Returns</strong>:</p>
<p><code>middle_of_log_bins, fPf, fPferror, Pf, Pferror</code>: np.ndarrays
<br>
See class documentation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rebin(self, num=50, init=False):
    &#34;&#34;&#34;
    Perform logarithmic rebinning.
    
    **Parameters**:
    
    `num`: int     
        The number of logarithmic frequency bins to create.
    
    `init`: boolean, optional, default: False     
        If False, creates the &#34;middle_of_log_bins, fPf, fPferror, Pf, Pferror&#34; for the first time with num=50 bins.
        If True, updates these attributes, using num bins.
        
    **Returns**:
    
    `middle_of_log_bins, fPf, fPferror, Pf, Pferror`: np.ndarrays     
        See class documentation. 
    &#34;&#34;&#34;
    
    middle_of_log_bins, fPf, fPferror = log_rebin(self.xf,self.fft_rate*self.xf,self.fft_rate_err*self.xf,num=num)
    middle_of_log_bins, Pf, Pferror = log_rebin(self.xf,self.fft_rate,self.fft_rate_err,num=num)
    
    if init:
        return middle_of_log_bins, fPf, fPferror, Pf, Pferror
    else:
        setattr(self, &#39;middle_of_log_bins&#39;, middle_of_log_bins)
        setattr(self, &#39;fPf&#39;, fPf)
        setattr(self, &#39;fPferror&#39;, fPferror)
        setattr(self, &#39;Pf&#39;, Pf)
        setattr(self, &#39;Pferror&#39;, Pferror)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="star" href="index.html">star</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="star.Powerspectrum.PowerSpectrum" href="#star.Powerspectrum.PowerSpectrum">PowerSpectrum</a></code></h4>
<ul class="two-column">
<li><code><a title="star.Powerspectrum.PowerSpectrum.Fvar_from_ps" href="#star.Powerspectrum.PowerSpectrum.Fvar_from_ps">Fvar_from_ps</a></code></li>
<li><code><a title="star.Powerspectrum.PowerSpectrum.fft_seg" href="#star.Powerspectrum.PowerSpectrum.fft_seg">fft_seg</a></code></li>
<li><code><a title="star.Powerspectrum.PowerSpectrum.noise_power" href="#star.Powerspectrum.PowerSpectrum.noise_power">noise_power</a></code></li>
<li><code><a title="star.Powerspectrum.PowerSpectrum.normalize_power" href="#star.Powerspectrum.PowerSpectrum.normalize_power">normalize_power</a></code></li>
<li><code><a title="star.Powerspectrum.PowerSpectrum.plot" href="#star.Powerspectrum.PowerSpectrum.plot">plot</a></code></li>
<li><code><a title="star.Powerspectrum.PowerSpectrum.powspec" href="#star.Powerspectrum.PowerSpectrum.powspec">powspec</a></code></li>
<li><code><a title="star.Powerspectrum.PowerSpectrum.rebin" href="#star.Powerspectrum.PowerSpectrum.rebin">rebin</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>